---
title: "[컴퓨터아키텍처] 5주차 수업 내용 정리"
excerpt: "싱글 사이클 프로세서, 파이프라인화에 대해 정리하였습니다."

tags: 
  - [Ocha, Computer Architecture]

date: 2025-06-03
last_modified_at: 2025-06-03

toc: true
toc_sticky: true
---

<br/>

## 명령 파이프라인

- 도입: 공장의 라인을 생각해 보자
	- 콘베이어 벨트 라인 위에 제품이 지나감
		- 4명의 사람이 각각 공정 작업을 해 나가며 완성됨
	- 제품이 하나밖에 나오지 않는다면 한 사람이 작업할 때 다른 사람들은 한가해짐
	- 실제 공장: **여러 제품을 동시에** 흐르게 하는 방식
		- 각 공정을 **병렬로 처리**함으로써 처리량을 향상시키는 방식임
		- 앞서 설명한 것보다 4배 빠른 속도로 제품이 완성됨
	- 이것이 바로 **명령 파이프라인** 방식임

	![](/attachments/computer-architecture-4-01.png)

<br/>

## 싱글 사이클 프로세서의 동작

- 모든 명령의 처리가 1 사이클 안에 완료되는 방식
	- 지금까지 설명했던 프로세서의 동작과 동일한 방식임
- 파이프라인화를 전제로 한, 더 구체적인 구조를 사용하여 복습하는 방식임

<br/>

### 지금까지 설명한 CPU의 이미지

- 컴퓨터의 핵심 부품
	- 메모리에서 명령을 읽어 계산을 수행하는 역할을 함

- 구성 요소
	- 연산기(FU: Functional Unit)
	    - 가산기나 AND 연산기 등
	    - 지시된 종류의 연산을 수행
	- 레지스터 파일 (오른쪽 그림에서는 A, B, C…)
	    - 메모리처럼 데이터를 저장하는 역할
		- 위치를 지정하여 읽기와 쓰기를 수행함
	    - CPU의 연산은 이 레지스터 상에서만 수행됨
	- PC (Program Counter)
	    - 현재 보고 있는 명령의 주소를 기억하는 장소

<br/>

### 베이스가 되는 싱글 사이클 프로세서

![](/attachments/computer-architecture-4-02.png)

- 이전에 설명했던 것과의 차이점
	- 메모리가 명령 메모리와 데이터 메모리로 나뉘어 있음
	- 산술 및 논리 연산, 로드, 스토어만 실행 가능함
	    - 분기와 점프는 간단히 하기 위해 지금은 고려하지 않음

<br/>

- 명령 하나의 실행 페이즈
	- 패치 フェッチ
	- 디코드 デコード
	- 레지스터 읽어 오기
	- 실행
	- 레지스터에 써 넣기

<br/>

- RISC-V의 덧셈 명령을 실행하는 흐름

	![](/attachments/computer-architecture-4-03.png)
	
	- **명령 패치**
		- 명령 메모리에서 명령을 읽어오는 방식
			- 명령 메모리를 순서대로 읽기 위해, **PC는 매 사이클마다 증가**함
			- 더해지는 4는, RISC-V에서 명령어의 크기가 **4바이트**이기 때문임
			- 기본적으로 이 부분은 어떤 명령에서도 변하지 않는 부분임

<br/>

	![](/attachments/computer-architecture-4-04.png)

	- **명령 디코드**
		- 받은 명령으로부터 레지스터 번호를 나타내는 부분의 비트를 읽어 옴
			- 소스 `rs1`, `rs2`와 데스티네이션 `rd`

<br/>

	![](/attachments/computer-architecture-4-05.png)

	- **레지스터 읽어 오기**
		- 디코드로부터 얻은 레지스터 번호를 이용해 RF에 액세스
			- 소스, 피연산자의 값을 읽어 옴

<br/>

	![](/attachments/computer-architecture-4-06.png)

	- **실행**
		- RF로부터 읽어 온 두 개의 값을 더함

<br/>

	![](/attachments/computer-architecture-4-07.png)

	- **레지스터에 써 넣기**
		- 덧셈의 결과를 레지스터와 파일에 써 넣음
		- 데이터, 메모리에는 아무 작업도 하지 않음

<br/>

- 로딩의 경우: 메모리, 액세스가 변경됨
	- 덧셈 명령과의 차이
		- 어드레스의 계산 `x[rs1] + immediate`을 ALU로 처리
		- 얻은 어드레스로 데이터와 메모리에 액세스

	![](/attachments/computer-architecture-4-08.png)

<br/>

- 각 처리는 기본적으로 왼쪽에서부터 오른쪽으로 흐름

	![](/attachments/computer-architecture-4-09.png)

	- 특정 유닛에서 작업하고 있을 때, 다른 유닛은 아무것도 하지 않음
	- 파이프라인화를 도입해, 처리를 오버랩하여 효율적인 처리가 가능하도록 함

<br/>

## 파이프라인화

![](/attachments/computer-architecture-4-10.png)

- 읽는 방법
	- 시간은 왼쪽에서 오른쪽으로 흐름
	- 명령은 위에서 아래로 실행 순서대로 배치됨
	- 각 스테이지를 나타내는 사각형은, 해당 시점에 왼쪽에 있는 명령이 그 위치에 존재함을 나타냄
		- 위의 예에서는 2사이클째에 I0이 ID에서 처리 중, I1이 IF에서 처리 중임

- 파이프라인화에 따른 성능 향상

<br/>

### 스테이지를 어떻게 나눌 것인가?

- 싱글 사이클 프로세서의 회로에 명령을 적당한 간격으로 흘려보내기만 하면 된다는 것은 아님
	1. 각 스테이지를 완전히 동일한 길이로 만드는 것은 매우 어려운 일임
		- 동일한 길이 = 동일한 지연 = 완전히 같은 단계 수의 조합 회로 구성
	2. 스테이지가 길더라도 신호는 끊임없이 변화할 가능성이 있음
		- 짧은 경로부터 순서대로 출력에 반영됨
		- 예를 들어 아래 회로에서 a, b, c, d가 모두 변할 경우, 먼저 d의 변화가 z에 반영되고, 그다음 d가...

	![](/attachments/computer-architecture-4-11.png)

<br/>

- 파이프라인화(오버랩)의 표현 방법
	- 싱글 사이클 프로세서에 플립플롭을 넣는 방식
		- 이를 위한 플립플롭을 파이프라인 래치라고 부름
			- 래치(latch)는 ‘문이나 대문의 걸쇠’라는 의미를 가짐
			- 파이프라인 래치로 나뉜 부분이 스테이지가 됨
	- 한 사이클 동안은 파이프라인 래치에서 신호가 멈춘 상태를 유지함
		- 여러 스테이지 간에 신호가 섞이는 것을 방지함
		- 지정된 시간까지 래치에서 문을 열지 않게 하는 이미지로 이해할 수 있음
	- 각 사람이 작업을 마쳤더라도, 래치가 열릴 때까지는 다음 사람에게 제품을 전달할 수 없음
		- 여러 스테이지 간에 신호가 섞이는 것을 방지함
		- 지정된 시간까지 래치에서 문을 열지 않게 하는 이미지로 이해할 수 있음
			- 아래 그림에서는 빨간 사람이 아직 작업을 끝내지 않았기 때문에, 전체가 보조를 맞추기 위해 기다리고 있는 상태임

	![](/attachments/computer-architecture-4-12.png)

<br/>

	- 각 스테이지 사이에 D-FF(주황색 사각형)을 넣는 방식
		- WB의 쓰기에 대해서는, 레지스터 파일 자체가 클록에 맞춰 쓰기가 이루어지므로 D-FF는 불필요함
		- 각 스테이지의 처리가 빨리 끝나더라도, 다음 클록까지는 D-FF로 신호 전달을 멈추는 방식임

	![](/attachments/computer-architecture-4-13.png)

<br/>

- **그래서 어디서 나눌 것인가?**
	- 큰 회로 단위를 스테이지로 구성하는 방식
		- 회로 단위가 클수록 -> 지연도 커지는 경향이 있음
	- 이러한 지연의 크기가 일정하지 않으면, 제대로 동작하지 않음
		-  파이프라인 전체는 가장 느린 스테이지의 지연에 맞춰 동작함
		- 다른 사람이 작업을 끝냈더라도, 먼저 보낼 수 없음
	- 좋지 않은 예시: 초록색 사람만 일이 많아서, 전체가 움직일 수 없는 상태가 됨

	- 스테이지
		1. IF: 명령어 페치
		2. ID: 디코드와 레지스터 읽기
		3. EX: 실행
		4. MEM: 메모리 접근
		5. WB: 레지스터 쓰기

	- 위에서는 디코드와 레지스터 읽기를 ID 스테이지에 통합한 형태임
		- 디코드에 걸리는 지연은 거의 없음
		- 읽어들인 명령어에서 오퍼랜드를 꺼내는 것은 단순히 신호선을 연결하는 것으로 가능함
